# List Sort

Challenge's README.md file is repasted below the solution.

Throughout my solution, I used a struct that contained shorts to store flinks, values, and lengths.

```
#pragma pack(1)
    struct Group {
        unsigned short flink;
        unsigned short value;
        unsigned short length;
    };
```

Next I opened the binary file:
```
int main()
{
    Group r;
    FILE *f;
	  f = fopen("input_stream.bin", "rb");
    ...
```

After opening the binary file, I began a while loop to go through the entire binary file and read in the struct I made. For storing the flagpiece, I created an array using the length member of the struct for the size. After reading in the struct, I read in the flagpiece into this array. After everything is read in, the flink, value, length, and flagpiece are outputted to the terminal in csv format.

In the beginning stages of creating this code, I changed the while loop to a for loop, read in a few parts of the linked list, and I used the online binary file viewer to verify that my code was storing everything properly.

```
    while (!feof(f))
    {
        // read in first three fields
        fread(&r, sizeof(struct Group),1,f);
        cout << r.flink << "," << r.value << "," << r.length << ",";

        // create char array to store flagpiece bytes
        unsigned char flagpc[r.length];

        // read in bytes for flag piece
        for (int j = 0; j < r.length; j++)
        {
            fread(&flagpc[(r.length-1)-j], 1,1,f);
        }    

        // print flagpiece bytes in hex
        for (int k = 0; k < r.length; k++)
        {
            printf("%02x", flagpc[k]);
        }
        cout << endl;
   ```

The loop continues to run until a flink is reached that has a value of 0xFFFF, which is equal to 65535.
```
        // go to next flink offset
        if (r.flink == 65535)
        {
            break;
        }
    }
 ```
 
 I piped the output of the terminal into a csv file and deleted the odd indexed rows.
 
<img width="500" alt="list2" src="https://user-images.githubusercontent.com/97570623/236570208-7774970c-82a6-43dc-8539-7dfebd62b1dd.PNG">


I pasted the flagpiece hex into a xor calculator, and submitted the ASCII decoding as the flag.

<img width="696" alt="list3" src="https://user-images.githubusercontent.com/97570623/236570566-f7bf1e43-4afc-4b1c-a408-ed719b5a707e.PNG">

<img width="672" alt="list4" src="https://user-images.githubusercontent.com/97570623/236570577-ad8cb561-9cb7-414f-b353-b7a553709cb4.PNG">

Notes: To make this solution complete (without the need for spreadsheeting), I would add code that stores the value-flagpiece structs into an array and create a sort function to sort the structs. From there, I could index through the array, add 2 to the index each time, xor the flagpieces, and store this result into a char array variable to be printed out to the terminal before decoding into ASCII.


Instructions: 

Write a sorting algorithm which will open the file `input_stream.bin`, load in a linked list which has been serialized, and sort the linked list from lowest to highest. The flag can be printed out using the secondary data fields of the linked list nodes. 

Note: Being able to do this in C is good practice for the interview.

Reading the Linked List
You have been provided the binary file, `input_stream.bin`. This file contains a linked list which has been serialized (meaning transferred into raw binary data).

Each linked list node takes the following form:
```
| Flink | Value |Length | Flag Piece... |
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | ......... |
```

Flink: The pointer to the next node in the list. The flink is given as an offset from the beginning of the binary file.
Value: The value which should be used to sort the linked list.
Length: Size, in bytes, of the Flag Piece
Flag Piece: You will use these bytes to generate the flag once the list is sorted. Note: Flag Pieces are of variable length (see the length parameter to know the number of bytes).

The first node in the linked list will begin at the start of the binary file (offset 0). The last node will have a Flink of 0xFFFF.

Printing the Flag
The flag is generated by XORing together the Flag Pieces of all of the nodes that fall on an even index in the list. Note that Flag Pieces will have different numbers of bytes, so align the first bytes and zero extend when necessary.

The flag will be represented in ASCII.

Example of a sorted list:
```
 |00|2|5|\x4f\x58\xe4\xa2\x7b
 |11|3|2|\x21\x12
 |19|6|4|\x29\x34\x85\xd9
 |29|9|1|\x69
```

XORing the Flag Pieces from index 0 and 2 yield: "flag{"

